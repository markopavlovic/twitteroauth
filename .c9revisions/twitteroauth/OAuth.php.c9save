{"ts":1347312816252,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n// vim: foldmethod=marker\n\n/* Generic exception class\n */\nclass OAuthException extends Exception {\n  // pass\n}\n\nclass OAuthConsumer {\n  public $key;\n  public $secret;\n\n  function __construct($key, $secret, $callback_url=NULL) {\n    $this->key = $key;\n    $this->secret = $secret;\n    $this->callback_url = $callback_url;\n  }\n\n  function __toString() {\n    return \"OAuthConsumer[key=$this->key,secret=$this->secret]\";\n  }\n}\n\nclass OAuthToken {\n  // access tokens and request tokens\n  public $key;\n  public $secret;\n\n  /**\n   * key = the token\n   * secret = the token secret\n   */\n  function __construct($key, $secret) {\n    $this->key = $key;\n    $this->secret = $secret;\n  }\n\n  /**\n   * generates the basic string serialization of a token that a server\n   * would respond to request_token and access_token calls with\n   */\n  function to_string() {\n    return \"oauth_token=\" .\n           OAuthUtil::urlencode_rfc3986($this->key) .\n           \"&oauth_token_secret=\" .\n           OAuthUtil::urlencode_rfc3986($this->secret);\n  }\n\n  function __toString() {\n    return $this->to_string();\n  }\n}\n\n/**\n * A class for implementing a Signature Method\n * See section 9 (\"Signing Requests\") in the spec\n */\nabstract class OAuthSignatureMethod {\n  /**\n   * Needs to return the name of the Signature Method (ie HMAC-SHA1)\n   * @return string\n   */\n  abstract public function get_name();\n\n  /**\n   * Build up the signature\n   * NOTE: The output of this function MUST NOT be urlencoded.\n   * the encoding is handled in OAuthRequest when the final\n   * request is serialized\n   * @param OAuthRequest $request\n   * @param OAuthConsumer $consumer\n   * @param OAuthToken $token\n   * @return string\n   */\n  abstract public function build_signature($request, $consumer, $token);\n\n  /**\n   * Verifies that a given signature is correct\n   * @param OAuthRequest $request\n   * @param OAuthConsumer $consumer\n   * @param OAuthToken $token\n   * @param string $signature\n   * @return bool\n   */\n  public function check_signature($request, $consumer, $token, $signature) {\n    $built = $this->build_signature($request, $consumer, $token);\n    return $built == $signature;\n  }\n}\n\n/**\n * The HMAC-SHA1 signature method uses the HMAC-SHA1 signature algorithm as defined in [RFC2104] \n * where the Signature Base String is the text and the key is the concatenated values (each first \n * encoded per Parameter Encoding) of the Consumer Secret and Token Secret, separated by an '&' \n * character (ASCII code 38) even if empty.\n *   - Chapter 9.2 (\"HMAC-SHA1\")\n */\nclass OAuthSignatureMethod_HMAC_SHA1 extends OAuthSignatureMethod {\n  function get_name() {\n    return \"HMAC-SHA1\";\n  }\n\n  public function build_signature($request, $consumer, $token) {\n    $base_string = $request->get_signature_base_string();\n    $request->base_string = $base_string;\n\n    $key_parts = array(\n      $consumer->secret,\n      ($token) ? $token->secret : \"\"\n    );\n\n    $key_parts = OAuthUtil::urlencode_rfc3986($key_parts);\n    $key = implode('&', $key_parts);\n\n    return base64_encode(hash_hmac('sha1', $base_string, $key, true));\n  }\n}\n\n/**\n * The PLAINTEXT method does not provide any security protection and SHOULD only be used \n * over a secure channel such as HTTPS. It does not use the Signature Base String.\n *   - Chapter 9.4 (\"PLAINTEXT\")\n */\nclass OAuthSignatureMethod_PLAINTEXT extends OAuthSignatureMethod {\n  public function get_name() {\n    return \"PLAINTEXT\";\n  }\n\n  /**\n   * oauth_signature is set to the concatenated encoded values of the Consumer Secret and \n   * Token Secret, separated by a '&' character (ASCII code 38), even if either secret is \n   * empty. The result MUST be encoded again.\n   *   - Chapter 9.4.1 (\"Generating Signatures\")\n   *\n   * Please note that the second encoding MUST NOT happen in the SignatureMethod, as\n   * OAuthRequest handles this!\n   */\n  public function build_signature($request, $consumer, $token) {\n    $key_parts = array(\n      $consumer->secret,\n      ($token) ? $token->secret : \"\"\n    );\n\n    $key_parts = OAuthUtil::urlencode_rfc3986($key_parts);\n    $key = implode('&', $key_parts);\n    $request->base_string = $key;\n\n    return $key;\n  }\n}\n\n/**\n * The RSA-SHA1 signature method uses the RSASSA-PKCS1-v1_5 signature algorithm as defined in \n * [RFC3447] section 8.2 (more simply known as PKCS#1), using SHA-1 as the hash function for \n * EMSA-PKCS1-v1_5. It is assumed that the Consumer has provided its RSA public key in a \n * verified way to the Service Provider, in a manner which is beyond the scope of this \n * specification.\n *   - Chapter 9.3 (\"RSA-SHA1\")\n */\nabstract class OAuthSignatureMethod_RSA_SHA1 extends OAuthSignatureMethod {\n  public function get_name() {\n    return \"RSA-SHA1\";\n  }\n\n  // Up to the SP to implement this lookup of keys. Possible ideas are:\n  // (1) do a lookup in a table of trusted certs keyed off of consumer\n  // (2) fetch via http using a url provided by the requester\n  // (3) some sort of specific discovery code based on request\n  //\n  // Either way should return a string representation of the certificate\n  protected abstract function fetch_public_cert(&$request);\n\n  // Up to the SP to implement this lookup of keys. Possible ideas are:\n  // (1) do a lookup in a table of trusted certs keyed off of consumer\n  //\n  // Either way should return a string representation of the certificate\n  protected abstract function fetch_private_cert(&$request);\n\n  public function build_signature($request, $consumer, $token) {\n    $base_string = $request->get_signature_base_string();\n    $request->base_string = $base_string;\n\n    // Fetch the private key cert based on the request\n    $cert = $this->fetch_private_cert($request);\n\n    // Pull the private key ID from the certificate\n    $privatekeyid = openssl_get_privatekey($cert);\n\n    // Sign using the key\n    $ok = openssl_sign($base_string, $signature, $privatekeyid);\n\n    // Release the key resource\n    openssl_free_key($privatekeyid);\n\n    return base64_encode($signature);\n  }\n\n  public function check_signature($request, $consumer, $token, $signature) {\n    $decoded_sig = base64_decode($signature);\n\n    $base_string = $request->get_signature_base_string();\n\n    // Fetch the public key cert based on the request\n    $cert = $this->fetch_public_cert($request);\n\n    // Pull the public key ID from the certificate\n    $publickeyid = openssl_get_publickey($cert);\n\n    // Check the computed signature against the one passed in the query\n    $ok = openssl_verify($base_string, $decoded_sig, $publickeyid);\n\n    // Release the key resource\n    openssl_free_key($publickeyid);\n\n    return $ok == 1;\n  }\n}\n\nclass OAuthRequest {\n  private $parameters;\n  private $http_method;\n  private $http_url;\n  // for debug purposes\n  public $base_string;\n  public static $version = '1.0';\n  public static $POST_INPUT = 'php://input';\n\n  function __construct($http_method, $http_url, $parameters=NULL) {\n    @$parameters or $parameters = array();\n    $parameters = array_merge( OAuthUtil::parse_parameters(parse_url($http_url, PHP_URL_QUERY)), $parameters);\n    $this->parameters = $parameters;\n    $this->http_method = $http_method;\n    $this->http_url = $http_url;\n  }\n\n\n  /**\n   * attempt to build up a request from what was passed to the server\n   */\n  public static function from_request($http_method=NULL, $http_url=NULL, $parameters=NULL) {\n    $scheme = (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] != \"on\")\n              ? 'http'\n              : 'https';\n    @$http_url or $http_url = $scheme .\n                              '://' . $_SERVER['HTTP_HOST'] .\n                              ':' .\n                              $_SERVER['SERVER_PORT'] .\n                              $_SERVER['REQUEST_URI'];\n    @$http_method or $http_method = $_SERVER['REQUEST_METHOD'];\n\n    // We weren't handed any parameters, so let's find the ones relevant to\n    // this request.\n    // If you run XML-RPC or similar you should use this to provide your own\n    // parsed parameter-list\n    if (!$parameters) {\n      // Find request headers\n      $request_headers = OAuthUtil::get_headers();\n\n      // Parse the query-string to find GET parameters\n      $parameters = OAuthUtil::parse_parameters($_SERVER['QUERY_STRING']);\n\n      // It's a POST request of the proper content-type, so parse POST\n      // parameters and add those overriding any duplicates from GET\n      if ($http_method == \"POST\"\n          && @strstr($request_headers[\"Content-Type\"],\n                     \"application/x-www-form-urlencoded\")\n          ) {\n        $post_data = OAuthUtil::parse_parameters(\n          file_get_contents(self::$POST_INPUT)\n        );\n        $parameters = array_merge($parameters, $post_data);\n      }\n\n      // We have a Authorization-header with OAuth data. Parse the header\n      // and add those overriding any duplicates from GET or POST\n      if (@substr($request_headers['Authorization'], 0, 6) == \"OAuth \") {\n        $header_parameters = OAuthUtil::split_header(\n          $request_headers['Authorization']\n        );\n        $parameters = array_merge($parameters, $header_parameters);\n      }\n\n    }\n\n    return new OAuthRequest($http_method, $http_url, $parameters);\n  }\n\n  /**\n   * pretty much a helper function to set up the request\n   */\n  public static function from_consumer_and_token($consumer, $token, $http_method, $http_url, $parameters=NULL) {\n    @$parameters or $parameters = array();\n    $defaults = array(\"oauth_version\" => OAuthRequest::$version,\n                      \"oauth_nonce\" => OAuthRequest::generate_nonce(),\n                      \"oauth_timestamp\" => OAuthRequest::generate_timestamp(),\n                      \"oauth_consumer_key\" => $consumer->key);\n    if ($token)\n      $defaults['oauth_token'] = $token->key;\n\n    $parameters = array_merge($defaults, $parameters);\n\n    return new OAuthRequest($http_method, $http_url, $parameters);\n  }\n\n  public function set_parameter($name, $value, $allow_duplicates = true) {\n    if ($allow_duplicates && isset($this->parameters[$name])) {\n      // We have already added parameter(s) with this name, so add to the list\n      if (is_scalar($this->parameters[$name])) {\n        // This is the first duplicate, so transform scalar (string)\n        // into an array so we can add the duplicates\n        $this->parameters[$name] = array($this->parameters[$name]);\n      }\n\n      $this->parameters[$name][] = $value;\n    } else {\n      $this->parameters[$name] = $value;\n    }\n  }\n\n  public function get_parameter($name) {\n    return isset($this->parameters[$name]) ? $this->parameters[$name] : null;\n  }\n\n  public function get_parameters() {\n    return $this->parameters;\n  }\n\n  public function unset_parameter($name) {\n    unset($this->parameters[$name]);\n  }\n\n  /**\n   * The request parameters, sorted and concatenated into a normalized string.\n   * @return string\n   */\n  public function get_signable_parameters() {\n    // Grab all parameters\n    $params = $this->parameters;\n\n    // Remove oauth_signature if present\n    // Ref: Spec: 9.1.1 (\"The oauth_signature parameter MUST be excluded.\")\n    if (isset($params['oauth_signature'])) {\n      unset($params['oauth_signature']);\n    }\n\n    return OAuthUtil::build_http_query($params);\n  }\n\n  /**\n   * Returns the base string of this request\n   *\n   * The base string defined as the method, the url\n   * and the parameters (normalized), each urlencoded\n   * and the concated with &.\n   */\n  public function get_signature_base_string() {\n    $parts = array(\n      $this->get_normalized_http_method(),\n      $this->get_normalized_http_url(),\n      $this->get_signable_parameters()\n    );\n\n    $parts = OAuthUtil::urlencode_rfc3986($parts);\n\n    return implode('&', $parts);\n  }\n\n  /**\n   * just uppercases the http method\n   */\n  public function get_normalized_http_method() {\n    return strtoupper($this->http_method);\n  }\n\n  /**\n   * parses the url and rebuilds it to be\n   * scheme://host/path\n   */\n  public function get_normalized_http_url() {\n    $parts = parse_url($this->http_url);\n\n    $port = @$parts['port'];\n    $scheme = $parts['scheme'];\n    $host = $parts['host'];\n    $path = @$parts['path'];\n\n    $port or $port = ($scheme == 'https') ? '443' : '80';\n\n    if (($scheme == 'https' && $port != '443')\n        || ($scheme == 'http' && $port != '80')) {\n      $host = \"$host:$port\";\n    }\n    return \"$scheme://$host$path\";\n  }\n\n  /**\n   * builds a url usable for a GET request\n   */\n  public function to_url() {\n    $post_data = $this->to_postdata();\n    $out = $this->get_normalized_http_url();\n    if ($post_data) {\n      $out .= '?'.$post_data;\n    }\n    return $out;\n  }\n\n  /**\n   * builds the data one would send in a POST request\n   */\n  public function to_postdata() {\n    return OAuthUtil::build_http_query($this->parameters);\n  }\n\n  /**\n   * builds the Authorization: header\n   */\n  public function to_header($realm=null) {\n    $first = true;\n\tif($realm) {\n      $out = 'Authorization: OAuth realm=\"' . OAuthUtil::urlencode_rfc3986($realm) . '\"';\n      $first = false;\n    } else\n      $out = 'Authorization: OAuth';\n\n    $total = array();\n    foreach ($this->parameters as $k => $v) {\n      if (substr($k, 0, 5) != \"oauth\") continue;\n      if (is_array($v)) {\n        throw new OAuthException('Arrays not supported in headers');\n      }\n      $out .= ($first) ? ' ' : ',';\n      $out .= OAuthUtil::urlencode_rfc3986($k) .\n              '=\"' .\n              OAuthUtil::urlencode_rfc3986($v) .\n              '\"';\n      $first = false;\n    }\n    return $out;\n  }\n\n  public function __toString() {\n    return $this->to_url();\n  }\n\n\n  public function sign_request($signature_method, $consumer, $token) {\n    $this->set_parameter(\n      \"oauth_signature_method\",\n      $signature_method->get_name(),\n      false\n    );\n    $signature = $this->build_signature($signature_method, $consumer, $token);\n    $this->set_parameter(\"oauth_signature\", $signature, false);\n  }\n\n  public function build_signature($signature_method, $consumer, $token) {\n    $signature = $signature_method->build_signature($this, $consumer, $token);\n    return $signature;\n  }\n\n  /**\n   * util function: current timestamp\n   */\n  private static function generate_timestamp() {\n    return time();\n  }\n\n  /**\n   * util function: current nonce\n   */\n  private static function generate_nonce() {\n    $mt = microtime();\n    $rand = mt_rand();\n\n    return md5($mt . $rand); // md5s look nicer than numbers\n  }\n}\n\nclass OAuthServer {\n  protected $timestamp_threshold = 300; // in seconds, five minutes\n  protected $version = '1.0';             // hi blaine\n  protected $signature_methods = array();\n\n  protected $data_store;\n\n  function __construct($data_store) {\n    $this->data_store = $data_store;\n  }\n\n  public function add_signature_method($signature_method) {\n    $this->signature_methods[$signature_method->get_name()] =\n      $signature_method;\n  }\n\n  // high level functions\n\n  /**\n   * process a request_token request\n   * returns the request token on success\n   */\n  public function fetch_request_token(&$request) {\n    $this->get_version($request);\n\n    $consumer = $this->get_consumer($request);\n\n    // no token required for the initial token request\n    $token = NULL;\n\n    $this->check_signature($request, $consumer, $token);\n\n    // Rev A change\n    $callback = $request->get_parameter('oauth_callback');\n    $new_token = $this->data_store->new_request_token($consumer, $callback);\n\n    return $new_token;\n  }\n\n  /**\n   * process an access_token request\n   * returns the access token on success\n   */\n  public function fetch_access_token(&$request) {\n    $this->get_version($request);\n\n    $consumer = $this->get_consumer($request);\n\n    // requires authorized request token\n    $token = $this->get_token($request, $consumer, \"request\");\n\n    $this->check_signature($request, $consumer, $token);\n\n    // Rev A change\n    $verifier = $request->get_parameter('oauth_verifier');\n    $new_token = $this->data_store->new_access_token($token, $consumer, $verifier);\n\n    return $new_token;\n  }\n\n  /**\n   * verify an api call, checks all the parameters\n   */\n  public function verify_request(&$request) {\n    $this->get_version($request);\n    $consumer = $this->get_consumer($request);\n    $token = $this->get_token($request, $consumer, \"access\");\n    $this->check_signature($request, $consumer, $token);\n    return array($consumer, $token);\n  }\n\n  // Internals from here\n  /**\n   * version 1\n   */\n  private function get_version(&$request) {\n    $version = $request->get_parameter(\"oauth_version\");\n    if (!$version) {\n      // Service Providers MUST assume the protocol version to be 1.0 if this parameter is not present. \n      // Chapter 7.0 (\"Accessing Protected Ressources\")\n      $version = '1.0';\n    }\n    if ($version !== $this->version) {\n      throw new OAuthException(\"OAuth version '$version' not supported\");\n    }\n    return $version;\n  }\n\n  /**\n   * figure out the signature with some defaults\n   */\n  private function get_signature_method(&$request) {\n    $signature_method =\n        @$request->get_parameter(\"oauth_signature_method\");\n\n    if (!$signature_method) {\n      // According to chapter 7 (\"Accessing Protected Ressources\") the signature-method\n      // parameter is required, and we can't just fallback to PLAINTEXT\n      throw new OAuthException('No signature method parameter. This parameter is required');\n    }\n\n    if (!in_array($signature_method,\n                  array_keys($this->signature_methods))) {\n      throw new OAuthException(\n        \"Signature method '$signature_method' not supported \" .\n        \"try one of the following: \" .\n        implode(\", \", array_keys($this->signature_methods))\n      );\n    }\n    return $this->signature_methods[$signature_method];\n  }\n\n  /**\n   * try to find the consumer for the provided request's consumer key\n   */\n  private function get_consumer(&$request) {\n    $consumer_key = @$request->get_parameter(\"oauth_consumer_key\");\n    if (!$consumer_key) {\n      throw new OAuthException(\"Invalid consumer key\");\n    }\n\n    $consumer = $this->data_store->lookup_consumer($consumer_key);\n    if (!$consumer) {\n      throw new OAuthException(\"Invalid consumer\");\n    }\n\n    return $consumer;\n  }\n\n  /**\n   * try to find the token for the provided request's token key\n   */\n  private function get_token(&$request, $consumer, $token_type=\"access\") {\n    $token_field = @$request->get_parameter('oauth_token');\n    $token = $this->data_store->lookup_token(\n      $consumer, $token_type, $token_field\n    );\n    if (!$token) {\n      throw new OAuthException(\"Invalid $token_type token: $token_field\");\n    }\n    return $token;\n  }\n\n  /**\n   * all-in-one function to check the signature on a request\n   * should guess the signature method appropriately\n   */\n  private function check_signature(&$request, $consumer, $token) {\n    // this should probably be in a different method\n    $timestamp = @$request->get_parameter('oauth_timestamp');\n    $nonce = @$request->get_parameter('oauth_nonce');\n\n    $this->check_timestamp($timestamp);\n    $this->check_nonce($consumer, $token, $nonce, $timestamp);\n\n    $signature_method = $this->get_signature_method($request);\n\n    $signature = $request->get_parameter('oauth_signature');\n    $valid_sig = $signature_method->check_signature(\n      $request,\n      $consumer,\n      $token,\n      $signature\n    );\n\n    if (!$valid_sig) {\n      throw new OAuthException(\"Invalid signature\");\n    }\n  }\n\n  /**\n   * check that the timestamp is new enough\n   */\n  private function check_timestamp($timestamp) {\n    if( ! $timestamp )\n      throw new OAuthException(\n        'Missing timestamp parameter. The parameter is required'\n      );\n    \n    // verify that timestamp is recentish\n    $now = time();\n    if (abs($now - $timestamp) > $this->timestamp_threshold) {\n      throw new OAuthException(\n        \"Expired timestamp, yours $timestamp, ours $now\"\n      );\n    }\n  }\n\n  /**\n   * check that the nonce is not repeated\n   */\n  private function check_nonce($consumer, $token, $nonce, $timestamp) {\n    if( ! $nonce )\n      throw new OAuthException(\n        'Missing nonce parameter. The parameter is required'\n      );\n\n    // verify that the nonce is uniqueish\n    $found = $this->data_store->lookup_nonce(\n      $consumer,\n      $token,\n      $nonce,\n      $timestamp\n    );\n    if ($found) {\n      throw new OAuthException(\"Nonce already used: $nonce\");\n    }\n  }\n\n}\n\nclass OAuthDataStore {\n  function lookup_consumer($consumer_key) {\n    // implement me\n  }\n\n  function lookup_token($consumer, $token_type, $token) {\n    // implement me\n  }\n\n  function lookup_nonce($consumer, $token, $nonce, $timestamp) {\n    // implement me\n  }\n\n  function new_request_token($consumer, $callback = null) {\n    // return a new token attached to this consumer\n  }\n\n  function new_access_token($token, $consumer, $verifier = null) {\n    // return a new access token attached to this consumer\n    // for the user associated with this token if the request token\n    // is authorized\n    // should also invalidate the request token\n  }\n\n}\n\nclass OAuthUtil {\n  public static function urlencode_rfc3986($input) {\n  if (is_array($input)) {\n    return array_map(array('OAuthUtil', 'urlencode_rfc3986'), $input);\n  } else if (is_scalar($input)) {\n    return str_replace(\n      '+',\n      ' ',\n      str_replace('%7E', '~', rawurlencode($input))\n    );\n  } else {\n    return '';\n  }\n}\n\n\n  // This decode function isn't taking into consideration the above\n  // modifications to the encoding process. However, this method doesn't\n  // seem to be used anywhere so leaving it as is.\n  public static function urldecode_rfc3986($string) {\n    return urldecode($string);\n  }\n\n  // Utility function for turning the Authorization: header into\n  // parameters, has to do some unescaping\n  // Can filter out any non-oauth parameters if needed (default behaviour)\n  public static function split_header($header, $only_allow_oauth_parameters = true) {\n    $pattern = '/(([-_a-z]*)=(\"([^\"]*)\"|([^,]*)),?)/';\n    $offset = 0;\n    $params = array();\n    while (preg_match($pattern, $header, $matches, PREG_OFFSET_CAPTURE, $offset) > 0) {\n      $match = $matches[0];\n      $header_name = $matches[2][0];\n      $header_content = (isset($matches[5])) ? $matches[5][0] : $matches[4][0];\n      if (preg_match('/^oauth_/', $header_name) || !$only_allow_oauth_parameters) {\n        $params[$header_name] = OAuthUtil::urldecode_rfc3986($header_content);\n      }\n      $offset = $match[1] + strlen($match[0]);\n    }\n\n    if (isset($params['realm'])) {\n      unset($params['realm']);\n    }\n\n    return $params;\n  }\n\n  // helper to try to sort out headers for people who aren't running apache\n  public static function get_headers() {\n    if (function_exists('apache_request_headers')) {\n      // we need this to get the actual Authorization: header\n      // because apache tends to tell us it doesn't exist\n      $headers = apache_request_headers();\n\n      // sanitize the output of apache_request_headers because\n      // we always want the keys to be Cased-Like-This and arh()\n      // returns the headers in the same case as they are in the\n      // request\n      $out = array();\n      foreach( $headers AS $key => $value ) {\n        $key = str_replace(\n            \" \",\n            \"-\",\n            ucwords(strtolower(str_replace(\"-\", \" \", $key)))\n          );\n        $out[$key] = $value;\n      }\n    } else {\n      // otherwise we don't have apache and are just going to have to hope\n      // that $_SERVER actually contains what we need\n      $out = array();\n      if( isset($_SERVER['CONTENT_TYPE']) )\n        $out['Content-Type'] = $_SERVER['CONTENT_TYPE'];\n      if( isset($_ENV['CONTENT_TYPE']) )\n        $out['Content-Type'] = $_ENV['CONTENT_TYPE'];\n\n      foreach ($_SERVER as $key => $value) {\n        if (substr($key, 0, 5) == \"HTTP_\") {\n          // this is chaos, basically it is just there to capitalize the first\n          // letter of every word that is not an initial HTTP and strip HTTP\n          // code from przemek\n          $key = str_replace(\n            \" \",\n            \"-\",\n            ucwords(strtolower(str_replace(\"_\", \" \", substr($key, 5))))\n          );\n          $out[$key] = $value;\n        }\n      }\n    }\n    return $out;\n  }\n\n  // This function takes a input like a=b&a=c&d=e and returns the parsed\n  // parameters like this\n  // array('a' => array('b','c'), 'd' => 'e')\n  public static function parse_parameters( $input ) {\n    if (!isset($input) || !$input) return array();\n\n    $pairs = explode('&', $input);\n\n    $parsed_parameters = array();\n    foreach ($pairs as $pair) {\n      $split = explode('=', $pair, 2);\n      $parameter = OAuthUtil::urldecode_rfc3986($split[0]);\n      $value = isset($split[1]) ? OAuthUtil::urldecode_rfc3986($split[1]) : '';\n\n      if (isset($parsed_parameters[$parameter])) {\n        // We have already recieved parameter(s) with this name, so add to the list\n        // of parameters with this name\n\n        if (is_scalar($parsed_parameters[$parameter])) {\n          // This is the first duplicate, so transform scalar (string) into an array\n          // so we can add the duplicates\n          $parsed_parameters[$parameter] = array($parsed_parameters[$parameter]);\n        }\n\n        $parsed_parameters[$parameter][] = $value;\n      } else {\n        $parsed_parameters[$parameter] = $value;\n      }\n    }\n    return $parsed_parameters;\n  }\n\n  public static function build_http_query($params) {\n    if (!$params) return '';\n\n    // Urlencode both keys and values\n    $keys = OAuthUtil::urlencode_rfc3986(array_keys($params));\n    $values = OAuthUtil::urlencode_rfc3986(array_values($params));\n    $params = array_combine($keys, $values);\n\n    // Parameters are sorted by name, using lexicographical byte value ordering.\n    // Ref: Spec: 9.1.1 (1)\n    uksort($params, 'strcmp');\n\n    $pairs = array();\n    foreach ($params as $parameter => $value) {\n      if (is_array($value)) {\n        // If two or more parameters share the same name, they are sorted by their value\n        // Ref: Spec: 9.1.1 (1)\n        natsort($value);\n        foreach ($value as $duplicate_value) {\n          $pairs[] = $parameter . '=' . $duplicate_value;\n        }\n      } else {\n        $pairs[] = $parameter . '=' . $value;\n      }\n    }\n    // For each parameter, the name is separated from the corresponding value by an '=' character (ASCII code 61)\n    // Each name-value pair is separated by an '&' character (ASCII code 38)\n    return implode('&', $pairs);\n  }\n}\n\n?>\n"]],"start1":0,"start2":0,"length1":0,"length2":26482}]],"length":26482}
